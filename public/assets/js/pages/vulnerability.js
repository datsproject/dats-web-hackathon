const saveVulnerabilityButton = document.getElementById("saveVulnerability");
const processingVulnerabilityButton = document.getElementById('processingVulnerability');
const approveVulnerabilitySwitch = document.getElementById("switchApproveVulnerability");
const webPenetrationCheckbox = document.getElementById("chkWebPenetration");
const serverPenetrationCheckbox = document.getElementById("chkServerPenetration");
const scadaPenetrationCheckbox = document.getElementById("chkScadaPenetration");
const blockchainPenetrationCheckbox = document.getElementById("chkBlockchainPenetration");
const contractPenetrationCheckbox = document.getElementById("chkContractPenetration");

document.addEventListener('DOMContentLoaded', async() => {
    if (supportedChains.includes(parseInt(window.ethereum.chainId, 16))) {
        if (parseInt(window.ethereum.chainId, 16) == 56) {
            contractAddress = '0x213f2D530e983897f52993B89d70e60cDDe91b0e';
            contractAbi = JSON.parse(bscContractAbi);
        }

        if (parseInt(window.ethereum.chainId, 16) == 8081) {
            contractAddress = '0xB42fC442857CF83a9dE80a74bB5865214fDc2ECd';
            contractAbi = JSON.parse(shardeumContractAbi);
        }

        if (parseInt(window.ethereum.chainId, 16) == 7001) {
            contractAddress = '0x6A907532d057daD23dD34df76ed571f76f85aeCE';
            contractAbi = JSON.parse(zetaContractAbi);
        }

        await getVulnerability();
    } else {
        saveVulnerabilityButton.disabled = true;
    }
});

async function saveVulnerability(isApprove, webPenetration, serverPenetration, scadaPenetration, blockchainPenetration, contractPenetration, callback) {

    saveVulnerabilityButton.classList.add("d-none");
    processingVulnerabilityButton.classList.remove("d-none");

    const datsContract = await contract(contractAbi, contractAddress);

    const listener = (id, consumer, data) => {
        console.log(`id: ${id}, consumer: ${consumer}, data: ${data}`);
        log.logInfo(`id: ${id}, consumer: ${consumer}, data: ${data}`);
    }

    datsContract.on("VulnerabilitySaved", listener);

    setTimeout(async() => {
        try {
            await datsContract.saveVulnerability(isApprove, webPenetration, serverPenetration, scadaPenetration, blockchainPenetration, contractPenetration);
            callback(saveVulnerabilityButton, processingVulnerabilityButton);
        } catch (error) {
            savedErrorNotify(error.message);
            saveVulnerabilityButton.classList.remove("d-none");
            processingVulnerabilityButton.classList.add("d-none");
        }
    }, 1000);
}

async function getVulnerability() {

    setTimeout(async() => {

        try {
            const datsContract = await contract(contractAbi, contractAddress);
            const vulnerabilityData = await datsContract.getVulnerability();
            if (vulnerabilityData && parseInt(vulnerabilityData.id, 16) > 0) {
                approveVulnerabilitySwitch.checked = vulnerabilityData.isApprove;
                webPenetrationCheckbox.checked = vulnerabilityData.webPenetration;
                serverPenetrationCheckbox.checked = vulnerabilityData.serverPenetration;
                scadaPenetrationCheckbox.checked = vulnerabilityData.scadaPenetration;
                blockchainPenetrationCheckbox.checked = vulnerabilityData.blockchainPenetration;
                contractPenetrationCheckbox.checked = vulnerabilityData.contractPenetration;
            } else {
                savedWarningNotify("Vulnerability Scanning settings are not saved in the contract. Please save your vulnerability scanning settings from Dats Desktop first.");
                saveVulnerabilityButton.disabled = true;
            }
        } catch (error) {
            console.log(`Get vulnerability scanning settings from contract error, ${error.message}`);
        }

    }, 1000);

}

saveVulnerabilityButton.addEventListener('click', async() => {
    await saveVulnerability(
        approveVulnerabilitySwitch.checked,
        webPenetrationCheckbox.checked,
        serverPenetrationCheckbox.checked,
        scadaPenetrationCheckbox.checked,
        blockchainPenetrationCheckbox.checked,
        contractPenetrationCheckbox.checked,
        (saveBtn, processingBtn) => {

            savedSuccessNotify();
            saveBtn.classList.remove("d-none");
            processingBtn.classList.add("d-none");

        });

});